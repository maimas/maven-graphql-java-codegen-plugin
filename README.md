
# GraphQL Java code generator Plugin
This is a maven plugin that generates TYPE SAFE java code from a remote GraphQL API,
so that you can have all the API methods and types in one generated source and easily build and execute query/mutations to the GQL server. 

It generates:
 - Types - object models including fields constants
 - InputObjects - graphql input objects schema
 - Queries - functions that takes arguments and output fields to build the GQL query or mutation. 

### Why this plugin exists?
Let's assume you have a java service that needs to call a remote GQL API to create a user `create(user: UserInput!): User`.
In order to create the user by calling GQL API, you need to know 3 things:
 1. `UserInput` object schema.
 2. `Output Field names` to be included in the result
 2. `Output object schema` - if you want to deserialize HTTP response body in to an User object.
 - This is how this mutation query string would look like:
 ````
query: {
    mutation create ($userInput: UserInput!) {
      create(user: $userInput) {
        id
        firstName
        lastName
        enabled
        status
      }
    }
}

variables : {
  "userInput": {
    "email": "tet2.test@test.com",
    "password": "1234", 
  }
}
````

- This is how you can build it with API generated by the plugin:
````
import static com.maimas.generated.UserServiceGraphQLProvider.*;
.......
Types.UserInput userInput = new Types.UserInput();
        userInput.email = "tet11.test@test.com";
        userInput.password = "1234";

GQLQuery query = new Mutation().create(
                input
                    .user(userInput),
                output -> output
                    .id()
                    .lastName()
                    .firstName()
                    .enabled()
                    .status());
````

As you noticed,  ``UserServiceGraphQLProvider`` class, is generated by the plugin and contains all the types ``UserInput``,``GQLQuery``,``UserFragment``...that the schema from remote GQL API supports. 

``GQLQuery`` is a builder for our GQL mutation, it needs a method that we want to execute, parameters of the method, and output fields that we want to return in the result set. 

## How to use.

### Prerequisites
- Java 17 or newer
- Maven 3.6.3 or newer

In your pom.xml under the ``build>plugins`` section add codegen plugin: 
````
    <build>
        <plugins>
        ....
            <plugin>
                <groupId>com.github.maimas</groupId>
                <artifactId>graphql-codegen-maven-plugin</artifactId>
                <version>3.0.0</version>
                <configuration>
                    <servers>
                        <server>
                            <!--from where to fetch schema conf-->
                            <url>http://localhost:8080/graphql</url>
                            <headers>
                                <header>jwt:DAAAgadwqcEJTUIU54WFFYUJgsd</header>
                                <header>Content-Type:application/json;charset=UTF-8</header>
                            </headers>
                            <!--where to store generated code-->
                            <resultClassName>UserServiceGraphQLProvider</resultClassName>
                            <resultClassPackage>com.maimas.generated</resultClassPackage>
                            <dir>./src/test/java/com/maimas/generated</dir>
                        </server>
                    </servers>
                </configuration>
            </plugin>
          ....
        </plugins>
    </build>
````

> Configuration

| Tag |Required| Description |
| --- | --- | --- |
| `url`                | required | URL of the server that exposes GraphQL API that we want to generate the schema for. |
| `headers`            | optional | Http headers to be added in the http request while fetching the GQL API JSON schema. Useful in specially when the API is secured and an access token needs to be injected in the request headers.  |
| `resultClassName`    | optional | Name of the class name to be generated, if not provided default value will be used `GeneratedGraphqlAPI`  |
| `resultClassPackage` | optional | Package of the generated class name, if not provided default value will be used `com.maimas.graphql.generated`  |
| `dir`                | optional | Directory where to store the generated class, if not provided default value will be used `./generated`  |

Additional configuration (advanced):
- language: Select target language. Default Java. Example: <language>Java</language> or <language>Typescript</language> (TypeScript). See Extending to additional languages below.
- failOnValidationError: When true (default), generation will fail if the generated code does not pass validation. Set to false to allow migration without failing the build.
- validationErrorOutputFile: Optional file path to write validation errors to. If provided, detailed validation errors will be written to this file for easier troubleshooting.
- connectTimeoutMs, socketTimeoutMs: HTTP timeouts in milliseconds used when fetching the GraphQL schema (defaults 5000/5000).
- maxRetries, retryBackoffMs: Retry behavior for transient 5xx/IO errors (defaults 2 retries, 500 ms base backoff).

Multiple servers example with headers and network settings:
````
<configuration>
  <servers>
    <server>
      <url>https://api.example.com/graphql</url>
      <headers>
        <header>Authorization:Bearer ${env.TOKEN}</header>
        <header>Content-Type:application/json;charset=UTF-8</header>
      </headers>
      <resultClassName>ExampleGraphQLProvider</resultClassName>
      <resultClassPackage>com.example.generated</resultClassPackage>
      <dir>./src/generated/java</dir>
      <language>Java</language>
      <failOnValidationError>true</failOnValidationError>
      <validationErrorOutputFile>./target/validation-errors.txt</validationErrorOutputFile>
      <connectTimeoutMs>10000</connectTimeoutMs>
      <socketTimeoutMs>15000</socketTimeoutMs>
      <maxRetries>3</maxRetries>
      <retryBackoffMs>750</retryBackoffMs>
    </server>
    <server>
      <url>http://localhost:8081/graphql</url>
      <resultClassName>LocalGraphQLProvider</resultClassName>
      <resultClassPackage>com.local.generated</resultClassPackage>
      <dir>./target/generated-sources/graphql</dir>
    </server>
  </servers>
</configuration>
````

Headers format notes:
- Each header is a single string in the form "Name:Value". The first ':' splits the name and value; additional ':' are allowed in the value.
- Leading/trailing spaces are trimmed. Empty values are supported. Malformed entries (missing ':', empty name) are skipped with a warning.

## Network configuration

The plugin fetches the GraphQL schema over HTTP and provides configurable timeouts and retry behavior.

Retry behavior:
- The plugin retries on transient server errors (HTTP 5xx) and IOExceptions (connection errors, timeouts).
- By default it will retry up to 2 times with an exponential linear backoff based on retryBackoffMs (attempt 1 waits backoff, attempt 2 waits 2x backoff, etc.).
- Responses with status 200 that contain a GraphQL "errors" array are treated as failures and will not be retried.

Options:
- connectTimeoutMs: Milliseconds to establish the TCP connection. Default 5000.
- socketTimeoutMs: Milliseconds to wait for data after the connection is established. Default 5000.
- maxRetries: Maximum number of retry attempts for 5xx/IO exceptions. Default 2. Set to 0 to disable retries.
- retryBackoffMs: Base delay in milliseconds between retries. Default 500. Each subsequent retry multiplies the delay by the attempt number.

Examples:
1) Slower network with longer timeouts and more retries
````
<server>
  <url>https://api.example.com/graphql</url>
  <connectTimeoutMs>15000</connectTimeoutMs>
  <socketTimeoutMs>30000</socketTimeoutMs>
  <maxRetries>5</maxRetries>
  <retryBackoffMs>1000</retryBackoffMs>
</server>
````

2) Disable retries (fail fast)
````
<server>
  <url>https://api.example.com/graphql</url>
  <maxRetries>0</maxRetries>
</server>
````

3) Authenticated request with header and custom timeouts
````
<server>
  <url>https://secure.example.com/graphql</url>
  <headers>
    <header>Authorization:Bearer ${env.TOKEN}</header>
  </headers>
  <connectTimeoutMs>8000</connectTimeoutMs>
  <socketTimeoutMs>8000</socketTimeoutMs>
</server>
````

Environment requirements:
- Java 17+ and Maven 3.6.3+ are required. The build enforces this via maven-enforcer-plugin.

> Generate API
>
Execute plugin from your IDE, or run in your terminal following maven command:
``mvn graphql-codegen-maven-plugin:generate``

Expect similar output:
````
[INFO] --- graphql-codegen-maven-plugin:1.0-SNAPSHOT:generate (default-cli) @ sr-user-service ---
[INFO] Starting to generate GraphQL API(s) for '1' servers...
[INFO] Server: {"url":"http://localhost:8080/graphql","headers":["jwt:DAAAgadwqcEJTUIU54WFFYUJgsd","Content-Type:application/json;charset=UTF-8"],"la
nguage":"Java","resultClassName":"UserServiceGraphQLProvider","resultClassPackage":"com.maimas.generated","dir":"./src/test/java/com/maimas/generated
","httpHeaders":{"jwt":"DAAAgadwqcEJTUIU54WFFYUJgsd","Content-Type":"application/json;charset=UTF-8"}}

[INFO] GraphQL API class generated at ./src/test/java/com/maimas/generated
````

### How to use generated API:
- Note: generated class name is `UserServiceGraphQLProvider` 

> Mutation - create user
````

//Imports from the Generated API
import com.maimas.generated.UserServiceGraphQLProvider.Types.User;
import com.maimas.generated.UserServiceGraphQLProvider.Types.UserInput;
import static com.maimas.generated.UserServiceGraphQLProvider.*;

public class Examples {

    public void queryByUserId() throws JsonProcessingException {
        UserInput userInput = new UserInput();
        userInput.email = "tet11.test@test.com";
        userInput.password = "1234";

        GQLQuery query = new Mutation().create(input -> 
                input
                    .user(userInput),
                output -> output
                    .id()
                    .lastName()
                    .firstName()
                    .enabled()
                    .status());

        ResponseEntity<String> response = new RestTemplate()
                .postForEntity("http://localhost:8080/graphql", query.toString(), String.class);

        // User user = (User) new ObjectMapper().readValue(response.getBody(), query.getReturnType());
        //
        // query.getReturnType() - represents the TypeReference of the expected result
        // that can be used if you want to convert the result to an object

    }
}
```` 

> Query - get user by id

````

//Imports from the Generated API
import com.maimas.generated.UserServiceGraphQLProvider.Types.User;
import static com.maimas.generated.UserServiceGraphQLProvider.*;

public class Examples {

    public void queryByUserId() throws JsonProcessingException {


        GQLQuery query = new Query().findById(input -> 
                input
                    .id("123123"),
                output -> output
                     .email()
                     .roles()
                     .name());

        ResponseEntity<String> response = new RestTemplate()
                .postForEntity("http://localhost:8080/graphql", query.toString(), String.class);

        // User user = (User) new ObjectMapper().readValue(response.getBody(), query.getReturnType());
        //
        // query.getReturnType() - represents the TypeReference of the expected result
        // that can be used if you want to convert the result to an object

    }
}
````

## Code Validation

The plugin includes a built-in `CodeValidator` that ensures the generated code is syntactically correct. This validation helps catch issues early in the development process.

### Types of Validation

The validator performs several checks on the generated code:

1. **Basic Syntax Validation**
   - Verifies proper package declaration (e.g., `package com.example;`)
   - Checks for class declaration (`public class ...`)

2. **Brace Balance Validation**
   - Ensures opening and closing braces are balanced
   - Reports the exact count of mismatched braces if found

3. **Semicolon Validation**
   - Checks for missing semicolons in statements
   - Validates field declarations, assignments, and other statements
   - Handles special cases like inline content within braces

### Validation Error Reporting

When validation fails:
- Detailed error messages are logged with line numbers when available
- The build fails by default (controlled by `failOnValidationError` setting)
- Error messages indicate the specific validation rule that failed

### Common Validation Issues and Solutions

| Issue | Possible Cause | Solution |
| --- | --- | --- |
| Missing package declaration | Template issue or custom template missing package | Ensure your template includes a proper package declaration |
| Unbalanced braces | Template syntax error or incomplete code generation | Check template for missing closing braces or conditional blocks |
| Missing semicolons | Incomplete statements in templates | Add semicolons to statements in your templates |
| Build fails with validation errors | Generated code has syntax issues | Temporarily set `failOnValidationError` to false to examine the generated code |

## Troubleshooting

- Build fails with validation errors:
  - By default, the plugin validates generated code and fails the build if issues are found. You can temporarily disable this by setting <failOnValidationError>false</failOnValidationError> for a specific server while migrating.
  - For detailed validation error reports, set <validationErrorOutputFile>./path/to/errors.txt</validationErrorOutputFile> to write all validation errors and suggested fixes to a file.
  - Common validation errors include:
    - **Missing package declaration**: Ensure your template starts with a proper package declaration.
    - **Unbalanced braces**: Check for missing closing braces in template conditional blocks.
    - **Missing semicolons**: Add semicolons to field declarations and assignments in templates.
  - To debug validation issues:
    1. Set `validationErrorOutputFile` to get detailed error reports
    2. Set `failOnValidationError` to false to generate the code despite errors
    3. Examine the generated code for syntax issues
    4. Check the error file and logs for specific validation error messages
    5. Fix the underlying template or schema issue
    6. Re-enable validation by setting `failOnValidationError` to true
- Network errors/timeouts:
  - Adjust <connectTimeoutMs> and <socketTimeoutMs> to suit your environment. Transient 5xx/IO errors are retried up to <maxRetries> with backoff <retryBackoffMs>. Inspect the status code and body snippet in the error message.
- GraphQL returned errors with HTTP 200:
  - The fetcher parses the "errors" array and surfaces messages and paths. Verify headers (auth tokens), query permissions, and server logs.
- Malformed headers configuration:
  - Headers must be in the form Name:Value. The first ':' is used to split name and value; empty names are skipped with a warning. Quotes are not required.
- Missing template resource:
  - If you customize language/templates, ensure the template path and the <Language>_GraphQL_Builders.txt resource exist in the classpath/resources.

## Extending to additional languages

You can plug in support for additional target languages without changing the generation pipeline:

- Templates are managed by TemplateRegistry and configured via TemplateConfig.
- TemplateProcessor resolves the template by the configured language name (UserConfig.language) and reads template properties like templatePath and fileExtension.

To add a new language:
- Create your FreeMarker schema template resource, e.g. resources path: <language>/Your_GQL_schema_template.ftl
- Provide a corresponding <Language>_GraphQL_Builders.txt resource containing the builder classes for that language (same convention as Java_GraphQL_Builders.txt).
- Register a TemplateConfig in TemplateRegistry (static block or via registerTemplate at startup):
  TemplateConfig tsConfig = new TemplateConfig("TypeScript", "1.0")
      .setProperty("fileExtension", ".ts")
      .setProperty("templatePath", "ts/TS_GQL_schema_template.ftl")
      .setProperty("scalarMappings", new java.util.HashMap<String,String>() {{
          put("ID", "string");
          put("Int", "number");
          put("String", "string");
          put("Boolean", "boolean");
          put("Float", "number");
      }});
  TemplateRegistry.registerTemplate(tsConfig);
- Use UserConfig.language = Selector.Typescript (TypeScript) or another enum value you add to select the language.

Notes:
- Scalar mappings are read in templates via templateConfig.properties.scalarMappings and can be customized per language.
- If a template resource is missing, TemplateProcessor will fail fast with a clear error.

## Programmatic usage

In addition to the Maven Mojo, you can generate code programmatically (useful for custom tooling/tests):

```
import com.maimas.graphql.generator.UserConfig;
import com.maimas.graphql.schema.processor.TemplateProcessor;

UserConfig cfg = new UserConfig();
cfg.setLanguage(UserConfig.Selector.Java);
cfg.setUrl("https://your.graphql.endpoint/graphql");
cfg.setResultClassName("GeneratedGraphqlAPI");
cfg.setResultClassPackage("com.example.generated");
cfg.setDir("./target/generated-sources/graphql");
// Optional network and validation settings
cfg.setConnectTimeoutMs(5000);
cfg.setSocketTimeoutMs(5000);
cfg.setMaxRetries(2);
cfg.setRetryBackoffMs(500);
cfg.setFailOnValidationError(true);
cfg.setValidationErrorOutputFile("./target/validation-errors.txt");

TemplateProcessor tp = new TemplateProcessor(cfg);
String generated = tp.generate();
System.out.println("Generated length: " + generated.length());
```

## Authors

* **Andrei Maimas**
