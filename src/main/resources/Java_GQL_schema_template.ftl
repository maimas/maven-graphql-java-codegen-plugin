package ${package};

<#-- Helper to detect if a GraphQL type (possibly nested NON_NULL) is a LIST -->
<#function isListType t>
    <#if (t.kind??)>
        <#if t.kind == "LIST">
            <#return true>
        <#elseif t.kind == "NON_NULL" && t.ofType??>
            <#return isListType(t.ofType)>
        </#if>
    </#if>
    <#return false>
</#function>

<#-- Compute whether we need List and Consumer imports -->
<#assign hasList=false>
<#assign usesConsumer=false>
<#list schema.types as t>
    <#-- Check object fields for list usage -->
    <#if isUserObjectType(t)>
        <#list t.fields as f>
            <#if isListType(f.type)>
                <#assign hasList=true>
            </#if>
        </#list>
    </#if>
    <#-- Check input object fields for list usage -->
    <#if t.name!="" && !t.name?starts_with("__") && typeKindEquals(t,"INPUT_OBJECT") && !t.name?upper_case?matches("QUERY|MUTATION")>
        <#list t.inputFields as f>
            <#if isListType(f.type)>
                <#assign hasList=true>
            </#if>
        </#list>
    </#if>
    <#-- Check if we generate Query/Mutation methods that use Consumer -->
    <#if typeKindEquals(t,"OBJECT") && (typeNameEquals(t,"QUERY") || typeNameEquals(t,"MUTATION")) && (t.fields??) && (t.fields?size > 0)>
        <#assign usesConsumer=true>
    </#if>
</#list>

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.util.RawValue;

import java.util.Optional;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.HashMap;
<#if hasList>import java.util.List;
</#if><#if usesConsumer>import java.util.function.Consumer;
</#if>


/**
* GENERATED BY MAVEN-GRAPHQL-JAVA-CODEGEN-PLUGIN.
*/
public class ${className} {

public static class Schema {

}

public static class Types {
<#--ENUM generation {-->
<#list schema.types as type>
    <#if type.name!="" && !type.name?starts_with("__") && typeKindEquals(type,"ENUM")>

        public enum ${type.name} {
        <#list type.enumValues as enum>
            ${enum.name}<#sep>,</#sep>
        </#list>
        }
    </#if>
</#list>
<#--ENUM generation }-->

<#--OBJECT generation {-->
<#list schema.types as type>
    <#if isUserObjectType(type)>
        <#if (type.description??) && type.description!="">
            /**
            * ${type.description}
            */
        </#if>
        public static class ${type.name} {
        <#list type.fields as field>
            public ${getFieldType(field, "")}  ${field.name};
        </#list>
        public static final class Fields {
        <#list type.fields as field>
            public static String ${field.name} = "${field.name}";
        </#list>
        }
        }
    </#if>
</#list>
<#--OBJECT generation }-->

<#--OBJECT fragment generation {-->
<#list schema.types as type>
    <#if isUserObjectType(type)>
        <#if (type.description??) && type.description!="">
            /**
            * ${type.description}
            */
        </#if>
        public static class ${type.name}Fragment {
        private final ResultFragment resultFragment = new ResultFragment();

        <#list type.fields as field>
            public ${type.name}Fragment ${field.name}() {
            resultFragment.add(FragmentField.of("${field.name}"));
            return this;
            }
        </#list>

        public ResultFragment getFragment() {
        return resultFragment;
        }
        }
    </#if>
</#list>
<#--OBJECT fragment generation }-->

<#--SCALAR fragment generation {-->
<#list schema.types as type>
    <#if type.name!="" && !type.name?starts_with("__") && typeKindEquals(type,"SCALAR") && type.name?upper_case?matches("BOOLEAN")>
        /**
         * Fragment for Boolean scalar type
         */
        public static class BooleanFragment {
            private final ResultFragment resultFragment = new ResultFragment();

            public ResultFragment getFragment() {
                return resultFragment;
            }
        }
    </#if>
</#list>
<#--SCALAR fragment generation }-->

<#--INPUT_OBJECT generation {-->
<#list schema.types as type>
    <#if type.name!="" && !type.name?starts_with("__") && typeKindEquals(type,"INPUT_OBJECT") && !type.name?upper_case?matches("QUERY|MUTATION")>
        ${getTypeDescription(type)}
        public static class ${type.name} {
        <#list type.inputFields as field>
            public ${getFieldType(field, "")}  ${field.name};
        </#list>
        }
    </#if>
</#list>
<#--INPUT_OBJECT generation }-->
}

<#--QUERY & MUTATION generation {-->
<#list schema.types as type>
    <#if typeKindEquals(type,"OBJECT") && (typeNameEquals(type,"QUERY") || typeNameEquals(type,"MUTATION"))>

        ${getTypeDescription(type)}
        public static class ${type.name} {

        <#list type.fields as field>
            /**
            * Generates GraphQL query string to perform "${field.name}" operation.
            *
            * @return - graphql query string.
            */
            public GQLQuery ${field.name}(Consumer< ${getAsFirstCapitalized(field.name)}Args> input,
                                          Consumer< ${getFragmentType(field, "Types.")} > output){

            final ${getAsFirstCapitalized(field.name)}Args args = new ${getAsFirstCapitalized(field.name)}Args();
            input.accept(args);
            final Arguments arguments = args.getArguments();

            final ${getFragmentType(field, "Types.")} fragment = ${createFragmentInstance(field, "Types.")};
            output.accept(fragment);
            final ResultFragment resultFragment = fragment.getFragment();


            GQLFunction function = new GQLFunction(GQLFunctionType.${getTypeName(type)}, "${field.name}")
            .arguments(arguments)
            .resultFragment(resultFragment)
            .returnType(new TypeReference<${getFieldType(field, "Types.")}>() {});

            return GQLQuery.from(function);
            }

            /**
            * Arguments provider.
            *
            * @return - ${getAsFirstCapitalized(field.name)}Args for "${field.name}" operation.
            */
            public class ${getAsFirstCapitalized(field.name)}Args {
            private Arguments arguments = new Arguments();

            ${buildArgumentMethods(field)}

            private Arguments getArguments() {
            return arguments;
            }
            }

        </#list>
        }
    </#if>
</#list>
<#--QUERY & MUTATION generation }-->

<#--GraphQL Builders content (a set of java classes) {-->
${gqlBuildersContent}
<#--GraphQL Builders content (a set of java classes) }-->

}

<#--Template funtions-->
<#function getAsFirstCapitalized value>
    <#if (value??)>
        <#return value?cap_first>
    <#else>
        <#return "">
    </#if>
</#function>


<#function buildArgumentMethods field>
    <#local result="">
    <#if (field.args??)>
        <#assign argsSize = field.args?size>
        <#list field.args as arg>
            <#if (arg.name??)>
                <#if isArgOptional(arg)>
                    <#local result += "public "+getAsFirstCapitalized(field.name)+"Args "+arg.name+"(Optional<"+getFieldType(arg, "Types.")+"> "+arg.name+") {
                    arguments.add(Argument.of(\""+arg.name+"\", "+arg.name+"));
                    return this;
                    }">
                <#else>
                    <#local result += "public "+getAsFirstCapitalized(field.name)+"Args "+arg.name+"("+getFieldType(arg, "Types.")+" "+arg.name+") {
                    arguments.add(Argument.of(\""+arg.name+"\", "+arg.name+"));
                    return this;
                    }">
                </#if>
            </#if>
        </#list>
    </#if>
    <#return result>
</#function>

<#-- Improved function to handle complex nested types with scalar mappings (overridable via templateConfig) -->
<#function resolveType type typePrefix>
    <#assign typeName = "">
    <#assign typeKind = "">

    <#if (type.kind??)>
        <#assign typeKind = type.kind>
    </#if>

    <#-- Handle NON_NULL types -->
    <#if typeKind == "NON_NULL" && type.ofType??>
        <#return resolveType(type.ofType, typePrefix)>
    </#if>

    <#-- Handle LIST types -->
    <#if typeKind == "LIST" && type.ofType??>
        <#assign innerType = resolveType(type.ofType, typePrefix)>
        <#return "List<" + innerType + ">">
    </#if>

    <#-- Handle named types -->
    <#if (type.name??)>
        <#assign typeName = type.name>
        <#-- Prefer template-provided scalar mappings if available -->
        <#assign scalarMappings = (templateConfig.properties.scalarMappings)!{}>
        <#assign mapped = scalarMappings[typeName]?if_exists>
        <#if !(mapped??)><#assign mapped = scalarMappings[typeName?lower_case]?if_exists></#if>
        <#if !(mapped??)><#assign mapped = scalarMappings[typeName?upper_case]?if_exists></#if>
        <#if mapped??>
            <#return mapped>
        </#if>
        <#-- Fallback defaults -->
        <#if typeName?lower_case == "id">
            <#return "String">
        <#elseif typeName?lower_case == "int">
            <#return "Integer">
        <#elseif typeName?lower_case?matches("boolean|string|date|float")>
            <#return typeName>
        </#if>
        <#return typePrefix + typeName>
    </#if>

    <#-- Handle ofType as fallback -->
    <#if (type.ofType??) && (type.ofType.name??)>
        <#assign typeName = type.ofType.name>
        <#assign scalarMappings = (templateConfig.properties.scalarMappings)!{}>
        <#assign mapped = scalarMappings[typeName]?if_exists>
        <#if !(mapped??)><#assign mapped = scalarMappings[typeName?lower_case]?if_exists></#if>
        <#if !(mapped??)><#assign mapped = scalarMappings[typeName?upper_case]?if_exists></#if>
        <#if mapped??>
            <#return mapped>
        </#if>
        <#if typeName?lower_case == "id">
            <#return "String">
        <#elseif typeName?lower_case == "int">
            <#return "Integer">
        <#elseif typeName?lower_case?matches("boolean|string|date|float")>
            <#return typeName>
        </#if>
        <#return typePrefix + typeName>
    </#if>

    <#-- Default fallback -->
    <#return "Object">
</#function>

<#function getFieldType field typePrefix>
    <#return resolveType(field.type, typePrefix)>
</#function>

<#function typeKindEquals type value>
    <#if (type.kind??)>
        <#return type.kind?upper_case?matches(value?upper_case)>
    <#else>
        <#return false>
    </#if>
</#function>

<#function typeNameEquals type value>
    <#if (type.name??)>
        <#return type.name?upper_case?matches(value?upper_case)>
    <#else>
        <#return false>
    </#if>
</#function>

<#function getTypeName type>
    <#if (type.name??)>
        <#return type.name?capitalize>
    <#else>
        <#return "">
    </#if>
</#function>

<#function buildMethodArguments field>
    <#local result="">
    <#if (field.args??)>
        <#assign argsSize = field.args?size>
        <#list field.args as arg>
            <#if (arg.name??)>
                <#if isArgOptional(arg)>
                    <#local result += "Optional<" + getFieldType(arg, "Types.") + "> " + arg.name>
                <#else>
                    <#local result += getFieldType(arg, "Types.") + " " + arg.name>
                </#if>
                <#if arg?index < argsSize-1>
                    <#local result +=", ">
                </#if>
            </#if>
        </#list>
    </#if>
    <#return result>
</#function>

<#function buildFragmentArguments field>
    <#local result="">
    <#if (field.args??)>
        <#assign argsSize = field.args?size>
        <#list field.args as arg>
            <#if (arg.name??)>
                <#local result += "Argument.of(\"${arg.name}\", ${arg.name})">
                <#if arg?index < argsSize-1>
                    <#local result +=", ">
                </#if>
            </#if>
        </#list>
    </#if>
    <#return result>
</#function>

<#function isArgOptional arg>
    <#if (arg.type.kind??) && arg.type.kind == "NON_NULL">
        <#return false>
    </#if>
    <#return true>
</#function>

<#function getTypeDescription type>
    <#assign description="">
    <#if (type.description??) && type.description!="">
        <#assign description="
        /**
        * ${type.description}
        */">
    </#if>
    <#return description>
</#function>

<#function isUserObjectType type>
    <#if type.name!="" && !type.name?starts_with("__") && typeKindEquals(type,"OBJECT") && !type.name?upper_case?matches("QUERY|MUTATION")>
        <#return true>
    </#if>
    <#return false>
</#function>

<#-- Function to get the appropriate fragment type for a field -->
<#function getFragmentType field typePrefix>
    <#-- For List types, we still use the per-item fragment type -->
    <#if field.type.kind == "LIST" && field.type.ofType??>
        <#local innerType = resolveType(field.type.ofType, typePrefix)>
        <#return innerType + "Fragment">
    <#else>
        <#return getFieldType(field, typePrefix) + "Fragment">
    </#if>
</#function>

<#-- Function to create a new fragment instance for a field -->
<#function createFragmentInstance field typePrefix>
    <#-- For List types, create the inner fragment instance (per-item selection set) -->
    <#if field.type.kind == "LIST" && field.type.ofType??>
        <#local innerType = resolveType(field.type.ofType, typePrefix)>
        <#return "new " + innerType + "Fragment()">
    <#else>
        <#return "new " + getFieldType(field, typePrefix) + "Fragment()">
    </#if>
</#function>
